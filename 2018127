链表是一种基础的数据结构。使用C语言实现链表，有助于加深对链表与对C语言指针的理解，让我们进入链表的练习。

1. 链表结点类型定义如下：
```c
struct Node {
	int val;
	struct Node* next;
};
```
写一个函数，函数声明如下：
```c
struct Node* construct(int arr[], int size);
```
接受整型数组arr与其大小size。该函数根据数组arr，构造一个链表，并返回链表的头结点。注意，保持链表中元素的顺序与数组中元素的顺序一致。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为1.c）。
***
2. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* insert(struct Node* head, int val);
```
接受一链表的头结点head，以及一个元素值val。该函数以val为元素值创建一个新的节点，将该节点插入该链表的头部，并返回插入后的链表头节点。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为2.c）。
***
3. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* insert(struct Node* head, int val);
```
接受一链表的头结点head，以及一个元素值val。该函数以val为元素值创建一个新的节点，将该节点插入该链表的尾部，并返回插入后的链表头节点。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为3.c）。
***
4. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* insert(struct Node* head, int val);
```
接受一有序（非降序）链表的头结点head。该函数以val为元素创建一个新的节点，并将该节点插入到该链表合适的位置，以维持链表的有序性。函数返回插入后的链表头节点。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为4.c）。
***
5. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* delete(struct Node* head, struct Node* target);
```
接受一链表的头结点head，以及该链表中的某节点target。该函数将target节点从该链表中删除，并返回删除后的链表头结点；若删除后链表为空，返回NULL。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：target节点有可能就是头结点，须注意；程序命名为5.c）。
***
6. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* delete(struct Node* head, int val);
```
接受一链表的头结点head，以及一个元素值val。该函数将该链表中所有元素值为val的节点删除，并返回删除后的链表头结点；若删除后链表为空，返回NULL。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为6.c）。
***
7. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* reverse(struct Node* head);
```
接受一链表的头结点head。该函数将该链表进行原地（in-place）反转（即不允许重新创建一个新的链表），并返回反转后链表的头节点。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为7.c）。
***
8. 在上周作业的第7题归并排序的实现中，你已经了解了将两个有序数组有序归并为一个更大数组的方法。现在，我们来对两个有序链表进行有序归并。
链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
struct Node* merge(struct Node* head1, struct Node* head2);
```
分别接受两个有序（非降序）链表的头结点，分别为head1与head2。该函数实现将这两个链表进行有序（非降序）归并到一个新的链表中，并返回所归并后的新链表的头节点。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为8.c）。
***
9. 链表结点类型定义同第1题。写一个函数，函数声明如下：
```c
void clear(struct Node* head);
```
接受一链表的头结点head。该函数将该链表清空，即删除所有节点，并释放其内存空间。写出完整的程序，在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为9.c）。
以上几道链表题，你应当熟练掌握。
***
10. 求数组的逆序对的个数。
```
题目描述：对于给定的数组arr，若有arr[i] > arr[j]，其中i < j，则arr[i]与arr[j]为数组arr的一个逆序对。现给定数组arr，求arr的逆序对的个数。
```
```
输入：第一行，正整数n，表示数组的大小，n≤40000。第二行，数组的n个数。
```
```
输出：输出数组的逆序对的个数。
```
```
样例输入：
6
5 4 2 6 3 1
样例输出：
11
```
（提示：在归并排序的基础上进行思考; 注：程序命名为10.c）
***
下面是语法练习题。

语法练习题

要求：

（1） 对于以下几道语法练习题，请给出答案，并给出每一题对应的解释，写在一个文本文件中，命名为exercise.md，与c语言代码一起提交。

（2） 你应当通过肉眼观察即给出答案，而不能写程序运行以获得结果；当然，在你完成后，你可以写程序运行以验证你的答案。

（3） 语法练习题与编程题同样重要，请认真对待，并确保弄懂每一题。
***
1. 若已有定义：```int a = 2, b = 3, c = 4；```则表达式```!(a + b) – c + 1 || c + b / 2```的值是（）。
***
2. 执行C程序代码：
```c
int a = 1, b = 2;
int c, d;
c = (a & b) && a;
d = (a && b) & a;
```
***
3. 若有定义语句：```int year = 1009; *p = &year; ```以下不能使变量year中的值增至 1010的语句是（）。
```c
int a = 1, b = 2;
int c, d;
c = (a & b) && a;
d = (a && b) & a;
```
A. *p += 1;

B. (*p)++;

C. ++(*p);

D. *p++;

***
4. 有一函数：
```c
int f(int x) {
	return (( x > 2) ? x * f(x - 1) : 3);
}
```
则f(f(2)的值为（）。
***
5. 有如下一段程序：
```c
int f1(float);
int f2(char);
int f3(float);
int f4(float);
int (*pf)(float);
```
则以下不合法的是:（）。
A. int (*p)(float) = &f1;

B. pf = &f4;

C. pf = &f2;

D. pf = f3;
***
6. 以下代码片段的输出结果为（）。
```c
char str[][10]={"China","Beijing"}, *p = str;
printf("%s\n", p + 10);
```
***
7. 有如下程序段：
```c
void GetMemeory(char *p) {
	p = (char *)malloc(100);
}
void Test() {
	char *str = NULL;
	GetMemeory(str);
	strcpy(str, "Thunder");
	strcat(str + 2, "Downloader");
	printf("%s", str);
}
```
运行Test函数结果是（）。

A. Thunder Downloader 

B. under Downloader

C. Thunderownloader

D. 程序崩溃
***
8. 若有定义：
```c
typedef char T[10] ;
T * a ;
```
上述定义中a的类型与下面选项中完全相同的是（）。

A. char a [ 10 ] ;

B. char ( *a) [ 10 ] ;

C. char * a ;

D. char *a [ 10 ] ;
***
9. 假定x = 65530，下面函数的返回值是（ ）。
```c
int func(x) {
	int countx = 0;
	while(x) {
		countx++;
		x = x & (x - 1);
	}
	return countx;
}
```
***
10. 下面这个程序执行后会有什么错误或者效果：
```c
#define MAX 255
int main() {
	unsigned char A[MAX], i;
	for (i = 0; i <= MAX; ++i)
		A[i] = i;
}
```
A. 数组越界

B. 死循环

C. 栈溢出

D. 内存泄漏

注：作业提交到自己仓库的`19180xxx/20181127`目录下。截止日期：`2018.12.4-00:00:00`（零点）。
